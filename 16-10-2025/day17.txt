1. Add Digits (Leetcode 258)

class Solution {
public:
    int addDigits(int num) {
        int sum = 0;
        while(num){
            int digit = num % 10;
            num /= 10;
            sum += digit;
        }
        return (sum >= 10) ? addDigits(sum) : sum;
    }
};

2. Leap Year (GeekforGeeks)

class Solution {
  public:
    bool checkYear(int n) {
        if(n%400 == 0 || (n%4 == 0 && n%100 != 0)) return true;
        return false;
    } 
};

3. Reverse Integer (Leetcode 7)

class Solution {
public:
    int reverse(int x) {
        long int rev_num = 0;
        int digit;
        while(x){
            digit = x % 10;
            x /= 10;
            rev_num = rev_num * 10 + digit;
            if (rev_num > INT_MAX || rev_num < INT_MIN) return 0;
        }
        return rev_num;
    }
};

4. Power of Two (Leetcode 231)

My Solution
class Solution {
public:
    bool isPowerOfTwo(int n) {
        if(n<0) return false;
        for(int i=0; i<=31; i++){
            if(pow(2,i) == n) return true;
        }
    return false;
    }
};

More Efficient Approach
class Solution {
public:
    bool isPowerOfTwo(int n) {
        if(n<1) return false;
        while(n != 1){
            if(n%2 == 1) return false;
            n /= 2;
        }
        return true;
    }
};

5. Sqrt(x) (Leetcode 69)

class Solution {
public:
    int mySqrt(int x) {
        long int n = 1;
        while(n*n <= x){
            n++;
        }
        return n-1;
    }
};

6. Pallindrome Number (Leetcode 9)

class Solution {
public:
    bool isPalindrome(int x) {
        if(x<0) return false;
        long num = x, rev_num = 0;
        while(num>0){
            int digit = num%10;
            rev_num = (rev_num * 10) + digit;
            num = num / 10;
        }
        return (x == rev_num);
    }
};

7. Complement of Base 10 Integer (Leetcode 1009/476)

1009
class Solution {
public:
    int bitwiseComplement(int n) {
        if(n == 0) return 1;
        int ans = 0, mul = 1, rem;
        while(n){
            rem = n % 2;
            rem = rem ^ 1; //use XOR to reverse 0->1 and 1->0
            ans += rem * mul;
            mul *= 2;
            n /= 2;
        }
        return ans;
    }
};

476
class Solution {
public:
    int findComplement(int n) {
        if (n == 0) return 1;
        long long ans = 0;
        long long mul = 1;
        int rem;
        while (n) {
            rem = n % 2;
            rem = rem ^ 1;
            ans += rem * mul;
            mul *= 2;
            n /= 2;
        }
        return (int)ans;
    }
};

8. Ugly Number (Leetcode 263)

class Solution {
public:
    bool isUgly(int n) {
        if(n<=0) return false;
        while (n % 2 == 0) n /= 2;
        while (n % 3 == 0) n /= 3;
        while (n % 5 == 0) n /= 5;
        return n == 1;
    }
};

9. Squares in N*N Chessboard (GeekforGeeks)

class Solution {
  public:
    long long squaresInChessBoard(long long N) {
        return (N*(N+1)*(2*N+1)/6);
    }
};

NB: A 4x4 Board has 16 1x1, 9 2x2, 4 3x3, 1 4x4 = 30 Squares
which basically shows a pattern of sum of squares of n natural numbers.
i.e. n(n+1)(2n+1)/6